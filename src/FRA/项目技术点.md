# 域名分发平台

## 一、AOP技术架构概述

###   1.1 依赖配置

  项目通过引入spring-boot-starter-aop依赖来启用AOP功能：

```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-aop</artifactId>
  </dependency>
```

###  1.2 AOP组件扫描与配置

  Spring Boot自动配置AOP功能，无需显式配置@EnableAspectJAutoProxy注解，系统会自动扫描带有@Component、@Service等注解
  的类，并将其注册为Bean。

##   二、异步处理AOP实现

###   2.1 异步配置类

```java
  // AsyncConfig.java
  @EnableAsync
  public class AsyncConfig {
      // 异步任务线程池配置
  }
```

  核心特性：

  - @EnableAsync：启用Spring的异步方法执行功能
  - 自动配置线程池，支持异步任务执行

###   2.2 异步邮件服务

```java
  // EmailService.java
  @Async
  public void sendVerificationCode(String email, String code, String type) {
      // 邮件发送逻辑
  }

  @Async
  public void sendWelcomeEmail(String email, String username) {
      // 欢迎邮件发送逻辑
  }
```

  实现机制：

  - AOP代理拦截：Spring AOP在运行时创建代理对象，拦截带有@Async注解的方法
  - 线程池执行：异步方法在独立线程中执行，不阻塞主线程
  - 非阻塞处理：邮件发送操作耗时较长，异步处理提升用户体验

##   三、限流机制深度解析

###   3.1 限流器组件设计

```java
  // RateLimiter.java
  @Component
  public class RateLimiter {
      private final StringRedisTemplate redis;

      public boolean tryConsume(String key, int limit, Duration window) {
          // 滑动窗口限流算法实现
      }

  }
```

  设计原理：

  - 分布式限流：基于Redis实现跨服务器实例的限流控制
  - 滑动窗口：支持时间窗口内的请求次数限制
  - 原子操作：利用Redis的原子性保证限流准确性

###   3.2 限流应用场景

  注册验证码限流

```java
  // AuthService.java:53
  public void sendRegisterCode(String email) {
      boolean allowed = rateLimiter.tryConsume("rl:regcode:" + email, 3, Duration.ofMinutes(1));
      if (!allowed)
          throw new IllegalArgumentException("请求过于频繁，请稍后再试");
  }
```

  限流规则：

  - 限流键：rl:regcode:{email} - 基于邮箱维度的限流
  - 限制次数：3次/分钟
  - 防护目标：防止恶意刷取验证码攻击

  密码重置限流

```java
  // AuthService.java:228
  public void startReset(String email) {
      boolean allowed = rateLimiter.tryConsume("rl:reset:" + email, 3, Duration.ofMinutes(1));
      if (!allowed)
          throw new IllegalArgumentException("请求过于频繁，请稍后再试");
  }
```

  限流策略：

  - 限流键：rl:reset:{email} - 密码重置专属限流
  - 时间窗口：1分钟内最多3次请求
  - 安全防护：避免密码重置接口被恶意利用

###   3.3 限流算法实现细节

  **Redis键值设计**

>   // 限流键格式
>   "rl:{业务类型}:{唯一标识}"
>   // 示例：
>   "rl:regcode:user@example.com"
>   "rl:reset:user@example.com"

  滑动窗口逻辑

```java
  public boolean tryConsume(String key, int limit, Duration window) {
      // 1. 获取当前时间戳
      long currentTime = System.currentTimeMillis();

      // 2. 使用Redis有序集合记录请求时间戳
      // ZADD key currentTime member
    
      // 3. 清理过期的请求记录
      // ZREMRANGEBYSCORE key 0 (currentTime - window.toMillis())
    
      // 4. 检查当前窗口内的请求数量
      // ZCARD key
    
      // 5. 判断是否超过限制
      return currentCount < limit;

  }
```



##   四、AOP与限流协同机制

###   4.1 组件注入与代理

```java
  // AuthService.java:31
  private final RateLimiter rateLimiter;

  public AuthService(..., RateLimiter rateLimiter, ...) {
      this.rateLimiter = rateLimiter;
  }
```

  依赖关系：

  - RateLimiter通过@Component注解被Spring管理
  - 在AuthService中注入限流器实例
  - Spring AOP为AuthService创建代理对象

###   4.2 方法调用流程

>   客户端请求 → Spring AOP代理 → 限流检查 → 业务逻辑执行 → 异步邮件发送
>                            ↓
>                     Redis限流验证

###   4.3 异常处理机制

  限流失败时抛出IllegalArgumentException，由全局异常处理器统一处理：

```java
  // GlobalExceptionHandler.java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(IllegalArgumentException.class)
      public ApiResponse<?> handleIllegalArgument(IllegalArgumentException e) {
          return ApiResponse.error(400, e.getMessage());
      }
  }
```

